THREE.OBJExporter=class{parse(t,e=""){let o="";o+="mtllib "+e+"\n";const r={};let n=0,i=0,f=0;const l=new THREE.Vector3,s=new THREE.Color,c=new THREE.Vector3,u=new THREE.Vector2,m=[];t.traverse((function(t){!0===t.isMesh&&function(t){let e=0,s=0,E=0;const a=t.geometry,y=t.material,g=new THREE.Matrix3;if(!0!==a.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const x=a.getAttribute("position"),p=a.getAttribute("normal"),d=a.getAttribute("uv"),T=a.getIndex();if(o+="o "+t.name+"\n",y){const t=""!==y.name?y.name:"material"+y.id;o+="usemtl "+t+"\n",r[t]=y}if(void 0!==x)for(let r=0,n=x.count;r<n;r++,e++)l.x=x.getX(r),l.y=x.getY(r),l.z=x.getZ(r),l.applyMatrix4(t.matrixWorld),o+="v "+l.x+" "+l.y+" "+l.z+"\n";if(void 0!==d)for(let t=0,e=d.count;t<e;t++,E++)u.x=d.getX(t),u.y=d.getY(t),o+="vt "+u.x+" "+u.y+"\n";if(void 0!==p){g.getNormalMatrix(t.matrixWorld);for(let t=0,e=p.count;t<e;t++,s++)c.x=p.getX(t),c.y=p.getY(t),c.z=p.getZ(t),c.applyMatrix3(g).normalize(),o+="vn "+c.x+" "+c.y+" "+c.z+"\n"}if(null!==T)for(let t=0,e=T.count;t<e;t+=3){for(let e=0;e<3;e++){const o=T.getX(t+e)+1;m[e]=n+o+(p||d?"/"+(d?i+o:"")+(p?"/"+(f+o):""):"")}o+="f "+m.join(" ")+"\n"}else for(let t=0,e=x.count;t<e;t+=3){for(let e=0;e<3;e++){const o=t+e+1;m[e]=n+o+(p||d?"/"+(d?i+o:"")+(p?"/"+(f+o):""):"")}o+="f "+m.join(" ")+"\n"}n+=e,i+=E,f+=s}(t),!0===t.isLine&&function(t){let e=0;const r=t.geometry,i=t.type;if(!0!==r.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const f=r.getAttribute("position");if(o+="o "+t.name+"\n",void 0!==f)for(let r=0,n=f.count;r<n;r++,e++)l.x=f.getX(r),l.y=f.getY(r),l.z=f.getZ(r),l.applyMatrix4(t.matrixWorld),o+="v "+l.x+" "+l.y+" "+l.z+"\n";if("Line"===i){o+="l ";for(let t=1,e=f.count;t<=e;t++)o+=n+t+" ";o+="\n"}if("LineSegments"===i)for(let t=1,e=t+1,r=f.count;t<r;t+=2,e=t+1)o+="l "+(n+t)+" "+(n+e)+"\n";n+=e}(t),!0===t.isPoints&&function(t){let e=0;const r=t.geometry;if(!0!==r.isBufferGeometry)throw new Error("THREE.OBJExporter: Geometry is not of type THREE.BufferGeometry.");const i=r.getAttribute("position"),f=r.getAttribute("color");if(o+="o "+t.name+"\n",void 0!==i)for(let r=0,n=i.count;r<n;r++,e++)l.fromBufferAttribute(i,r),l.applyMatrix4(t.matrixWorld),o+="v "+l.x+" "+l.y+" "+l.z,void 0!==f&&(s.fromBufferAttribute(f,r),o+=" "+s.r+" "+s.g+" "+s.b),o+="\n";o+="p ";for(let t=1,e=i.count;t<=e;t++)o+=n+t+" ";o+="\n",n+=e}(t)}));let E="";for(const t in r){const e=r[t];E+="newmtl "+t+"\n",E+="Ns 10.0\n",E+="Tr 0.0\n",E+="Tf 1.0 1.0 1.0\n",E+="Ka 1.0 1.0 1.0\n",E+="Kd "+e.color.r.toFixed(4)+" "+e.color.g.toFixed(4)+" "+e.color.b.toFixed(4)+" \n",E+="Ks 0.5 0.5 0.5\n",E+="Ke 0.0 0.0 0.0\n",E+="Ni 1.0\n",E+="d 1.0\n",E+="illum 2\n"}return{obj:o,mtl:E}}};