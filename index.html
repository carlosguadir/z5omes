<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
    <title>Z5omes | A Zome Maker</title>
    <meta name="description"
          content="Z5omes allows you to create 3D models for free. You can now create your models in GoodKarma and Semicone (Axis of symmetry) and export them in STL (sketchup import: mm unit, inverted YZ), OBJ or other formats.">

    <!-- Favicons -->
    <link rel="apple-touch-icon" sizes="180x180" href="img/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="img/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="img/favicons/favicon-16x16.png">
    <link rel="mask-icon" href="img/favicons/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#0d6efd">
    <meta name="theme-color" content="#ffffff">

    <!-- Stylesheets -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/fa.min.css" rel="stylesheet">
    <link href="css/flag-icons.css" rel="stylesheet">
    <link href="css/custom.css?v=1.0.7" rel="stylesheet">
</head>

<body class="bg-light">

<div x-data="settings" @zome-renderer-is-ready.window="__make_zome">
    <div class="loading-bar" x-show="is_computing">
        <div></div>
    </div>

    <div class="offcanvas offcanvas-end" tabindex="-1" data-bs-scroll="true" data-bs-backdrop="false"
         id="offcanvasSettings" aria-labelledby="settingsLabel">

        <div class="offcanvas-body">
            <div class="d-flex align-items-center mt-2 mb-3">
                <!-- Reset Params Button -->
                <button @click="reset_params" class="btn btn-primary btn-sm p-2 me-2"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_reset_settings')">
                    <i class="fa-solid fa-rotate"></i>
                </button>

                <!-- Save Params Button -->
                <button @click="save_params" class="btn btn-primary btn-sm p-2 me-2"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_save_settings')">
                    <i class="fa-solid fa-floppy-disk"></i>
                </button>

                <!-- Copy Link -->
                <button id="copy-url-btn" class="btn btn-primary btn-sm p-2 me-auto"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_copy_link')">
                    <i class="fa-solid fa-link"></i>
                </button>

                <!-- Language Dropdown -->
                <div class="dropdown">
                    <button class="btn btn-primary btn-sm dropdown-toggle"
                            type="button" data-bs-toggle="dropdown" aria-expanded="false">
                        <span class="fi fa-fw" :class="`fi-${params.language}`"></span>
                    </button>
                    <ul class="dropdown-menu">
                        <template x-for="(obj, lng) in I18N_LANGUAGES" :key="lng">
                            <li>
                                <button class="dropdown-item" @click="params.language = lng">
                                    <span class="fi" :class="`fi-${lng}`"></span>
                                    <span x-text="obj.name"></span>
                                </button>
                            </li>
                        </template>
                    </ul>
                </div>

                <!-- Show Help -->
                <button class="btn btn-sm p-1"
                        @click="params.help_is_displayed = !params.help_is_displayed"
                        :class="params.help_is_displayed ? 'text-primary' : 'text-secondary'"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_display_help')">
                    <i class="fa-solid fa-question-circle fa-fw"></i>
                </button>

                <!-- Close Button -->
                <button type="button" class="btn btn-sm p-1"
                        data-bs-dismiss="offcanvas"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_close')">
                    <i class="fa-solid fa-close fa-fw"></i>
                </button>
            </div>

            <div class="d-flex align-items-center mb-3">
                <h5 class="text-secondary my-1 me-3">
                    <i class="fa-solid fa-rhombus me-1"></i>
                    <span x-text="i18n('shape')" class="up-first"></span>
                </h5>

                <!-- Randomize Button -->
                <button @click="randomize_shape" class="btn btn-primary btn-sm p-2 me-auto"
                        data-bs-toggle="tooltip" :title="i18n('tooltip_randomize_shape')">
                    <i class="fa-solid fa-dice"></i>
                </button>
            </div>

            <div class="text-muted small aligned-form">
                <div x-show="params.help_is_displayed">
                    <p class="mb-1" x-text="i18n('help_shape')"></p>

                    <!-- Num of Order -->
                    <b>N</b> :
                    <span x-text="i18n('help_n_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_n_param')">
                        N
                    </span>
                    <input class="form-control form-range" max="24" min="3" step="1" type="range"
                           x-model.number="params.num" x-ref="num_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="params.num">
                </div>

                <!-- Num of rhombus from the top -->
                <div x-show="params.help_is_displayed">
                    <b>M</b> :
                    <span x-text="i18n('help_m_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_m_param')">
                        M
                    </span>
                    <input class="form-control form-range" min="1" :max="params.num - 1" step="1" type="range"
                           x-model.number="num_rhombus" x-ref="num_rhombus_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="num_rhombus">
                </div>

                <!--  Shape angle of Zome -->
                <div x-show="params.help_is_displayed">
                    <b>Θ | F</b> :
                    <span x-text="i18n('help_f_param')"></span>
                    <br>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <button class="btn btn-primary text-start" type="button"
                            data-bs-toggle="tooltip" :title="i18n('help_f_param')"
                            @click="params.angle_unit = (params.angle_unit == 'tan') ? 'deg': 'tan'"
                            x-text="(params.angle_unit == 'tan') ? 'F' : 'Θ'">
                    </button>
                    </span>
                    <input class="form-control form-range" min="30" max="70" step="0.01" type="range"
                           x-model.number="params.theta_deg" x-ref="theta_deg_slider">
                    <input class="form-control" type="number" step="0.01" x-model.lazy.number="theta">
                    <select class="form-select unit-select" aria-label="Angle unit"
                            x-show="params.angle_unit != 'tan'" x-model="params.angle_unit">
                        <option selected value="deg">deg</option>
                        <option value="rad">rad</option>
                        <option hidden value="tan">tan</option>
                    </select>
                </div>

                <!-- Height Ratio of Zome -->
                <div x-show="params.help_is_displayed">
                    <b>HR</b> :
                    <span x-text="i18n('help_hr_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                <span class="input-group-text"
                      data-bs-toggle="tooltip" :title="i18n('help_hr_param')">
                      HR
                </span>
                    <input class="form-control form-range" max="1" min="0" step="0.0000001" type="range"
                           :min="to_decimal(2 / params.num)"
                           x-model.number="params.height_ratio" x-ref="height_ratio_slider">
                    <input class="form-control" step="0.01" type="number"
                           x-model.lazy.number="params.height_ratio">
                    <button class="btn btn-primary"
                            data-bs-toggle="tooltip" :title="i18n('help_magnetize_param')"
                            type="button"
                            :class="(params.height_ratio == suggested_height_ratio) ? 'btn-secondary' : ''"
                            @click="magnetize">
                        <i class="fa-solid fa-magnet fa-fw"></i>
                    </button>
                </div>

                <!-- Kite Ratio of Zome -->
                <div x-show="params.help_is_displayed">
                    <b>KR</b> :
                    <span x-text="i18n('help_kr_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                <span class="input-group-text"
                      data-bs-toggle="tooltip" :title="i18n('help_kr_param')">
                    KR
                </span>
                    <input class="form-control form-range" max="1.5" min="0.5" step="0.01" type="range"
                           x-model.number="params.kite_ratio" x-ref="kite_ratio_slider">
                    <input class="form-control" step="0.01" type="number"
                           x-model.lazy.number="params.kite_ratio">
                    <button class="btn btn-primary" type="button"
                            data-bs-toggle="tooltip" :title="i18n('help_set_rhombus_param')"
                            :class="(is_rhombus) ? 'btn-secondary' : ''"
                            @click="is_rhombus = true">
                        <i class="fa-solid fa-rhombus fa-fw"></i>
                    </button>
                </div>
            </div>

            <hr>

            <div class="d-flex align-items-center mb-3">
                <h5 class="text-secondary my-1 me-3">
                    <i class="fa-solid fa-frame rotate-45 me-1"></i>
                    <span x-text="i18n('framework')" class="up-first"></span>
                </h5>

                <!-- Paint Button -->
                <button @click="params.paint_similar_pieces = !params.paint_similar_pieces"
                        class="btn btn-primary btn-sm p-2 me-auto"
                        data-bs-toggle="tooltip" :title="i18n('help_painting_param')">
                    <i class="fa-solid" :class="(params.paint_similar_pieces)? `fa-paintbrush` : `fa-paint-roller`"></i>
                </button>

                <select class="form-select form-select-sm unit-select"
                        aria-label="Measuring unit" x-model="params.measuring_unit">
                    <option value="mm">mm</option>
                    <option selected value="cm">cm</option>
                    <option value="m">m</option>
                </select>
            </div>

            <div class="text-muted small aligned-form">
                <!-- Height of Zome -->
                <div x-show="params.help_is_displayed">
                    <b>ZH</b> :
                    <span x-text="i18n('help_zh_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_zh_param')">
                    ZH
                    </span>
                    <input class="form-control form-range" min="100" max="10000" step="10" type="range"
                           x-model.number="params.zome_height_in_mm" x-ref="zome_height_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="zome_height">
                </div>

                <!-- Timber width -->
                <div x-show="params.help_is_displayed">
                    <b>TW</b> :
                    <span x-text="i18n('help_tw_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_tw_param')">
                          TW
                    </span>
                    <input class="form-control form-range" min="1" :max="max_timber_width" step="1" type="range"
                           x-model.number="params.timber_width_in_mm" x-ref="timber_width_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="timber_width">
                </div>

                <!-- Timber thickness -->
                <div x-show="params.help_is_displayed">
                    <b>TT</b> :
                    <span x-text="i18n('help_tt_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_tt_param')">
                        TT
                    </span>
                    <input class="form-control form-range" min="1" :max="max_timber_thickness" step="1"
                           type="range"
                           x-model.number="params.timber_thickness_in_mm" x-ref="timber_thickness_in_mm_slider">
                    <input class="form-control" step="1" type="number"
                           x-model.lazy.number="timber_thickness">
                </div>

                <!-- Strengthening of timbers -->
                <div x-show="params.help_is_displayed">
                    <b>ST</b> :
                    <span x-text="i18n('help_st_param')"></span>
                </div>
                <div class="input-group input-group-sm mb-3">
                    <span class="input-group-text"
                          data-bs-toggle="tooltip" :title="i18n('help_st_param')">
                        ST
                    </span>
                    <select class="form-select" aria-label="Assembly method"
                            x-model.number="params.strengthening_of_timbers">
                        <option selected value=0 x-text="i18n('opt_none')"></option>
                        <option value=1 x-text="i18n('opt_horizontal')"></option>
                        <option value=2 x-text="i18n('opt_vertical')"></option>
                    </select>
                </div>

                <!-- Assembly method -->
                <div x-show="params.help_is_displayed">
                    <b>AM</b> :
                    <span x-text="i18n('help_am_param')"></span>
                    <ul>
                        <li x-text="i18n('help_am_param_1')"></li>
                        <li x-text="i18n('help_am_param_2')"></li>
                        <li x-text="i18n('help_am_param_3')"></li>
                    </ul>
                </div>
                <div class="input-group input-group-sm mb-3">
                <span class="input-group-text"
                      data-bs-toggle="tooltip" :title="i18n('help_am_param_2')">
                    AM
                </span>
                    <button class="btn btn-primary" type="button"
                            :class="(params.assembly_method == 2)? `disabled`: ``"
                            data-bs-toggle="tooltip" :title="i18n('help_am_param_1')"

                            @click="params.xpansion_direction = -params.xpansion_direction">
                        <i class="fa-solid fa-fw"
                           :class="(params.xpansion_direction < 0 || params.assembly_method == 2)? `fa-arrow-up-from-line` : `fa-arrow-down-from-line`"></i>
                    </button>
                    <select class="form-select" aria-label="Assembly method"
                            x-model.number="params.assembly_method">
                        <option selected value=0>GoodKarma</option>
                        <option value=1>Beveled GoodKarma</option>
                        <option value=2>Outward Xpansion</option>
                    </select>
                    <button class="btn btn-primary" type="button"
                            data-bs-toggle="tooltip"
                            :title="i18n('help_am_param_3')"
                            @click="params.assembly_direction = (params.assembly_direction + 1) % ASSEMBLY_DIRECTION_ICONS.length">
                        <i class="fa-solid fa-fw"
                           :class="ASSEMBLY_DIRECTION_ICONS[params.assembly_direction]"
                        ></i>
                    </button>
                </div>

                <!-- Vanishing point -->
                <div x-show="params.assembly_method < 2">
                    <div x-show="params.help_is_displayed">
                        <b>VP</b> :
                        <span x-text="i18n('help_vp_param')"></span>
                    </div>
                    <div class="input-group input-group-sm mb-3">
                        <span class="input-group-text"
                              data-bs-toggle="tooltip" :title="i18n('help_vp_param')">
                            VP
                        </span>
                        <input class="form-control form-range" :min="min_z_vanishing_point" :max="max_z_vanishing_point"
                               step="1" type="range" x-model.number="params.z_vanishing_point_in_mm"
                               x-ref="z_vanishing_point_in_mm_slider">
                        <input class="form-control" step="1" type="number"
                               x-model.lazy.number="z_vanishing_point">
                        <button class="btn btn-primary" type="button"
                                data-bs-toggle="tooltip" :title="i18n('help_zc_param')"
                                :class="(is_vanishing_centered) ? 'btn-secondary' : ''"
                                @click="is_vanishing_centered = true">
                            <i class="fa-solid fa-arrows-to-circle fa-fw"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="auto-shift position-relative">
        <div class="container-xl row m-auto">
            <div class="col mb-3 mt-3">
                <div class="d-flex align-items-center">
                    <h2 id="#title" class="text-primary me-auto mb-0">
                        <a href="https://florianwns.github.io/z5omes/" class="text-decoration-none">
                            <img src="img/logo_zome.svg" width="48" alt="Zome Logo">
                            Z<span class="fs-4">o</span>oOo<span
                                class="fs-4">o</span>mes
                        </a>
                    </h2>

                    <a href="https://www.paypal.com/paypalme/z5omes"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_buymeacoffee')">
                        <i class="fa-solid fa-coffee"></i>
                    </a>

                    <a href="https://m.me/ch/AbbRFxmdmE3kybZR/"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_facebook')">
                        <i class="fa-brands fa-facebook"></i>
                    </a>

                    <a href="https://github.com/florianwns/z5omes"
                       class="text-primary btn btn-sm fs-4 p-2"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_github')">
                        <i class="fa-brands fa-github"></i>
                    </a>
                    <a href="https://www.linkedin.com/in/florian-rey-346857185/"
                       class="text-primary btn btn-sm fs-4 p-2 me-4"
                       data-bs-toggle="tooltip" :title="i18n('tooltip_link_linkedin')">
                        <i class="fa-brands fa-linkedin"></i>
                    </a>

                    <button class="btn btn-primary btn-sm p-2 px-3" type="button"
                            data-bs-toggle="offcanvas"
                            data-bs-target="#offcanvasSettings" aria-controls="offcanvasSettings">
                        <i class="fa-solid fa-sliders"></i>
                    </button>
                </div>

                <div class="d-flex flex-column">
                    <nav class="navbar mx-auto mt-2">
                        <ul class="nav nav-pills" id="nav-tab" role="tablist">
                            <li class="nav-item">
                                <button class="nav-link active" id="nav-3D-tab" data-bs-toggle="tab"
                                        data-bs-target="#nav-3D"
                                        type="button" role="tab" aria-controls="nav-3D" aria-selected="true">
                                    <i class="fa-solid fa-chart-pyramid me-1"></i>
                                    <span x-text="i18n('view_3D')" class="up-first"></span>
                                </button>
                            </li>
                            <li>
                                <button class="nav-link" id="nav-print-tab" data-bs-toggle="tab"
                                        data-bs-target="#nav-print"
                                        type="button" role="tab" aria-controls="nav-print" aria-selected="false">
                                    <i class="fa-solid fa-print me-1"></i>
                                    <span x-text="i18n('origami')" class="up-first"></span>
                                </button>
                            </li>
                        </ul>
                    </nav>
                    <div class="tab-content h-100 mt-3">
                        <div class="tab-pane show active" id="nav-3D" role="tabpanel" aria-labelledby="nav-3D-tab"
                             tabindex="0" x-data="renderer_3D" @resize.window="__auto_size"
                             @zome-is-made.window="process">
                            <div class="d-flex justify-content-center">
                                <div style="width:calc(100% - 72px); max-width: 700px;" class="position-relative">
                                    <!-- Export to -->
                                    <div class="ps-2 exports-container" style="top:0px;">
                                        <div class="vstack">
                                        <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                              data-bs-toggle="tooltip" :title="i18n('tooltip_export_2_format', 'STL')"
                                              @click="download_stl()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">STL</span>
                                        </span>
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'PLY')"
                                                  @click="download_ply()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">PLY</span>
                                        </span>
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'GLTF')"
                                                  @click="download_gltf()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">GLTF</span>
                                        </span>
                                            <span class="text-primary btn btn-sm fs-2 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'OBJ')"
                                                  @click="download_obj()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">OBJ</span>
                                        </span>
                                        </div>
                                    </div>


                                    <div class="mb-2">
                                        <!-- Draw Zome Env/ Zome Skeleton/ Zomandala -->
                                        <select class="form-select" aria-label="Type of 3D objects"
                                                x-model="type_of_3D_objects">
                                            <option selected value="skeleton_3D" x-text="i18n('skeleton_3D')"></option>
                                            <option value="cover_3D" x-text="i18n('cover_3D')"></option>
                                            <option value="mandala_3D" x-text="i18n('mandala_3D')"></option>
                                        </select>
                                    </div>
                                    <!-- Canvas for Zome 3D rendering -->
                                    <div x-ref="canvas_3D_container" class="position-relative">
                                        <div x-ref="canvas_3D" style="min-height:500px; cursor: move;"
                                             :style="(is_fullscreen)? `height:100%;` : `height:500px;`"
                                             class="shadow bg-dark rounded mb-2 overflow-hidden">
                                        </div>
                                        <div class="position-absolute end-0 bottom-0 p-2 d-flex flex-column gap-2">
                                            <!-- Keyboard shortcuts -->
                                            <button class="btn btn-primary"
                                                    data-bs-toggle="modal"
                                                    data-bs-target="#shortcuts-modal">
                                                <i class="fa-solid fa-keyboard"></i>
                                            </button>

                                            <!-- Fullscreen Toggle btn -->
                                            <button class="btn btn-primary"
                                                    x-show="can_use_screenfull"
                                                    @click="toggle_fullscreen"
                                                    data-bs-toggle="tooltip" :title="i18n('fullscreen')">
                                                <i class="fa fa-expand"></i>
                                            </button>
                                        </div>

                                        <!-- Keyboard shortcuts Modal -->
                                        <div class="modal fade" id="shortcuts-modal" tabindex="-1"
                                             aria-labelledby="shortcuts-modal-title" aria-hidden="true">
                                            <div class="modal-dialog modal-sm mt-2 me-2">
                                                <div class="modal-content">
                                                    <div class="modal-header">
                                                        <h5 class="text-secondary my-1 me-3" id="shortcuts-modal-title">
                                                            <i class="fa-solid fa-keyboard me-1"></i>
                                                            <span x-text="i18n('keyboard_shortcuts')"></span>
                                                        </h5>
                                                        <button type="button" class="btn-close" data-bs-dismiss="modal"
                                                                aria-label="Close"></button>
                                                    </div>
                                                    <div class="modal-body">
                                                        <ul class="keyboard-shorcut-list small text-muted">
                                                            <!-- Object selection -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('S')">S
                                                                </button>
                                                                <span x-text="i18n('key_S_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('E')">E
                                                                </button>
                                                                <span x-text="i18n('key_E_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('M')">M
                                                                </button>
                                                                <span x-text="i18n('key_M_3D_view')"></span>
                                                            </li>

                                                            <!-- Camera view -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('H')">H
                                                                </button>
                                                                <span x-text="i18n('key_H_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Left')">←
                                                                </button>
                                                                <span x-text="i18n('key_left_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Up')">↑
                                                                </button>
                                                                <span x-text="i18n('key_up_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Right')">→
                                                                </button>
                                                                <span x-text="i18n('key_right_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('Down')">↓
                                                                </button>
                                                                <span x-text="i18n('key_down_3D_view')"></span>
                                                            </li>

                                                            <!-- Object rotation -->
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key key-space me-2"
                                                                        @click="keydown(' ')"></button>
                                                                <span x-text="i18n('key_space_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('*')">*
                                                                </button>
                                                                <span x-text="i18n('key_mul_3D_view')"></span>
                                                            </li>
                                                            <li class="d-flex align-items-center mb-2">
                                                                <button class="key me-2" @click="keydown('/')">/
                                                                </button>
                                                                <span x-text="i18n('key_div_3D_view')"></span>
                                                            </li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                    <div class="d-flex flex-wrap justify-content-evenly">
                                        <!-- Draw Vanishing Lines -->
                                        <div class="form-check form-switch me-2 mb-3"
                                             x-show="show_vanishing_lines_switch">
                                            <label class="form-check-label" for="draw-vanishing-lines"
                                                   x-text="i18n('vanishing_lines')"></label>
                                            <input class="form-check-input" type="checkbox" role="switch"
                                                   id="draw-vanishing-lines" x-model="draw_vanishing_lines">
                                        </div>

                                        <!-- Draw Axis -->
                                        <div class="form-check form-switch me-2 mb-3">
                                            <label class="form-check-label" for="draw-axis-switch"
                                                   x-text="i18n('axis')"></label>
                                            <input class="form-check-input" type="checkbox" role="switch"
                                                   id="draw-axis-switch" x-model="draw_axis">
                                        </div>

                                        <!-- Draw Zome Vertices -->
                                        <div class="form-check form-switch me-2 mb-3" x-show="show_vertices_switch">
                                            <label class="form-check-label" for="draw-zome-vertices-switch"
                                                   x-text="i18n('vertices')"></label>
                                            <input class="form-check-input" type="checkbox" role="switch"
                                                   id="draw-zome-vertices-switch" x-model="draw_zome_vertices">
                                        </div>

                                        <!-- Spin -->
                                        <div class="form-check form-switch mb-3">
                                            <label class="form-check-label" for="spin-switch"
                                                   x-text="i18n('spin')"></label>
                                            <input class="form-check-input" type="checkbox" role="switch"
                                                   id="spin-switch" x-model="is_spinning">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="tab-pane" id="nav-print" role="tabpanel" aria-labelledby="nav-print-tab"
                             tabindex="0"
                             x-data="renderer_a4" @zome-is-made.window="process">
                            <div class="d-flex justify-content-center m-auto" style="max-width: calc(100% - 72px); ">
                                <div class="position-relative">
                                    <!-- Export to -->
                                    <div class="ps-2 exports-container" style="top:48px;">
                                        <div class="vstack">
                                        <span class="text-primary btn btn-sm fs-2 py-0 px-2 position-relative"
                                              data-bs-toggle="tooltip" :title="i18n('tooltip_export_2_format', 'SVG')"
                                              @click="download_svg()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">SVG</span>
                                        </span>
                                            <span class="text-primary btn btn-sm fs-2 py-0 px-2 position-relative"
                                                  data-bs-toggle="tooltip"
                                                  :title="i18n('tooltip_export_2_format', 'PDF')"
                                                  @click="download_pdf()">
                                            <i class="fa-solid fa-file"></i>
                                            <span class="fa-icon-file-type">PDF</span>
                                        </span>
                                        </div>
                                    </div>

                                    <div class="mb-2">
                                        <select class="form-select" aria-label="Kind of drawing"
                                                x-model="kind_of_drawing">
                                            <option selected value="mandala_figs" x-text="i18n('mandala')"></option>
                                            <option value="spiral_figs" x-text="i18n('spirals')"></option>
                                        </select>
                                    </div>

                                    <div class="ratio ratio-A4 bg-white rounded border position-relative">
                                        <!-- Svg Drawing -->
                                        <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%"
                                             viewbox="0 0 210 297" x-ref="A4_sheet">
                                        </svg>

                                        <!-- Grid Drawing -->
                                        <div class="position-absolute top-0 start-0" x-show="num_col > 1">
                                            <template x-for="(i, j) in  _.range(0, num_col * num_col )" :key="j">
                                                <div class="float-start border border-top-0 border-start-0"
                                                     :class="(((i + 1) % num_col == 0) ? 'border-end-0' : '')
                                                 + ((i >= num_col * (num_col - 1)) ? ' border-bottom-0' : '')"
                                                     :style="`width: ${grid_pct}%; height: ${grid_pct}%;`">
                                                </div>
                                            </template>
                                        </div>
                                    </div>

                                    <div class="input-group input-group-sm mt-2">
                                        <!-- Draw color -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip" :title="i18n('tooltip_draw_fig_color')"
                                                :class="draw_color ? '' : 'btn-secondary'"
                                                @click="draw_color = !draw_color">
                                            <i class="fa-regular fa-droplet fa-fw"></i>
                                        </button>

                                        <!-- Draw centroid -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip" :title="i18n('tooltip_draw_fig_centroid')"
                                                :class="draw_centroid ? '' : 'btn-secondary'"
                                                @click="draw_centroid = !draw_centroid">
                                            <i class="fa-regular fa-circle-dot fa-fw"></i>
                                        </button>

                                        <!-- Zoom Level -->
                                        <span class="input-group-text" data-bs-toggle="tooltip" title="Zoom level">
                                        <i class="fa-solid fa-magnifying-glass"></i>
                                    </span>
                                        <input class="form-control form-range" min="0.1" max="1" step="0.01"
                                               type="range"
                                               x-model.number="zoom" x-ref="zoom_slider">

                                        <!-- Num Col of Grid -->
                                        <button class="btn btn-primary" type="button"
                                                data-bs-toggle="tooltip"
                                                :title="i18n('tooltip_split_drawing')"
                                                @click="num_col = (num_col * 2 > 8) ? 1 : num_col * 2">
                                            <i class="fa-regular fa-grid-2-plus fa-fw"></i>
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="d-flex flex-wrap justify-content-center m-2 me-auto"
                                 style="max-height: 96px;overflow-y: auto;">
                                <template x-for="(color, i) in bulleted_list_colors" :key="i">
                                    <div class="px-1" @click="page_index = i">
                                        <div class="bulleted_list_item"
                                             :class="(page_index == i)? 'active' : ''"
                                             :style="`background-color: ${color};`"></div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="col-12 break-before" x-data="measurements" @zome-is-made.window="process">
                <hr>

                <div class="d-flex align-items-center">
                    <h5 class="text-secondary mt-4 mb-4 me-auto">
                        <i class="fa-solid fa-ruler-triangle me-1"></i>
                        <span x-text="i18n('measurements')"></span>
                    </h5>
                    <!-- CSV Button -->
                    <div>
                    <span class="text-primary btn btn-sm fs-2 px-2 position-relative" data-bs-toggle="tooltip"
                          :title="i18n('tooltip_export_2_format', 'TSV')"
                          @click="download_tsv()">
                        <i class="fa-solid fa-file"></i>
                        <span class="fa-icon-file-type">TSV</span>
                    </span>
                    </div>
                    <div>
                    <span class="text-primary btn btn-sm fs-2 px-2 position-relative" data-bs-toggle="tooltip"
                          title="Export to CSV format"
                          :title="i18n('tooltip_export_2_format', 'CSV')"
                          @click="download_csv()">
                        <i class="fa-solid fa-file"></i>
                        <span class="fa-icon-file-type">CSV</span>
                    </span>
                    </div>
                </div>

                <div class="row justify-content-between">
                    <div class="col-md-6 col-xl-5 mt-2">
                        <ul class="list-group small">
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('cover_num_figures')"></span>
                                <span class="badge bg-info rounded-pill" x-text="cover_num_figs"></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('cover_widest_diameter')"></span>
                                <span class="badge bg-info rounded-pill" x-text="cover_widest_diameter"></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('cover_area')"></span>
                                <span class="badge bg-info rounded-pill" x-text="cover_area"></span>
                            </li>
                        </ul>
                    </div>
                    <div class="col-md-6 col-xl-5 mt-2" x-show.important="has_floor">
                        <ul class="list-group small">
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('floor_perimeter')"></span>
                                <span class="badge bg-info rounded-pill" x-text="floor_perimeter"></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('floor_diameter')"></span>
                                <span class="badge bg-info rounded-pill" x-text="floor_diameter"></span>
                            </li>
                            <li class="list-group-item d-flex justify-content-between align-items-center">
                                <span x-text="i18n('floor_area')"></span>
                                <span class="badge bg-info rounded-pill" x-text="floor_area"></span>
                            </li>
                        </ul>
                    </div>
                    <div class="col-12 mt-3 mb-5">
                        <div class="table-responsive border border-bottom-0 bg-white rounded">
                            <table x-ref="dim-table" class="table text-center table-sm small table-striped-order m-0">
                                <thead class="bg-info text-white">
                                <tr>
                                    <th></th>
                                    <template x-for="(obj, i) in table_column_names" :key="i">
                                        <th x-text="obj"></th>
                                    </template>
                                </tr>
                                </thead>
                                <tbody>
                                <template x-for="(row, i) in table_rows" :key="i">
                                    <tr class="align-middle">
                                        <td>
                                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32"
                                                 :fill="row[0].color.hex">
                                                <polygon :points="to_svg_points(row[0], 32)"/>
                                            </svg>
                                        </td>
                                        <template x-for="(value, j) in row[1]" :key="j">
                                            <td x-text="value"></td>
                                        </template>
                                    </tr>
                                </template>
                                </tbody>
                                <tfoot>
                                </tfoot>
                            </table>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="toast-container position-fixed bottom-0 start-0 p-3">
        <div id="live_toast" class="toast fade" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body" id="toast_msg" class="me-auto">
                </div>
                <button type="button" class="btn-close me-2 m-auto" data-bs-dismiss="toast"
                        aria-label="Close"></button>
            </div>
        </div>
    </div>
</div>

<!-- Scripts / Bootstrap 5 runs without jQuery -->
<script src="js/popper.min.js"></script>
<script src="js/bootstrap.min.js"></script>

<!-- Lodash -->
<script src="js/lodash.min.js"></script>

<!-- ThreeJS -->
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.min.js"></script>
<script src="js/OBJExporter.min.js"></script>
<script src="js/STLExporter.min.js"></script>
<script src="js/PLYExporter.min.js"></script>
<script src="js/GLTFExporter.min.js"></script>

<!-- D3 -->
<script src="js/d3-polygon.min.js"></script>

<!-- Canvg -->
<script src="js/canvg.min.js"></script>

<!-- PDF Kit -->
<script src="js/pdfkit.min.js"></script>
<script src="js/blobstream.min.js"></script>
<script src="js/svg2pdf.min.js"></script>

<!-- Hammer : Touch events -->
<script src="js/hammer.min.js"></script>

<!-- Clipboard JS -->
<script src="js/clipboard.min.js"></script>

<!-- Screenfull -->
<script src="js/screenfull.min.js"></script>

<!-- i18n -->
<script src="i18n/i18n.js?v=1.0.7"></script>

<!-- Core and geometry functions -->
<script src="js/core.js?v=1.0.7"></script>

<!-- Alpine JS -->
<script defer src="js/alpine.min.js"></script>

<!-- Custom Javascript -->
<script type="text/javascript">
    const WORLD_HEIGHT = 1980;       // or 3D HEIGHT OF ZOME in mm
    const ASSEMBLY_DIRECTION_ICONS = ["fa-rotate-right", "fa-rotate-left", "fa-slash-back"]
    const DEBUG = false;
    const I18_DEFAULT_LANGUAGE = "en";

    // Use a global variable to store ZOME data
    let ZOME = new Zome({});

    document.addEventListener('alpine:init', () => {
        Alpine.data('measurements', () => {
            return {
                cover_figs: [],
                floor: null,

                __to_real_world: null,
                async init() {
                    this.__to_real_world = _.debounce(this.to_real_world, 1);
                },
                get figs() {
                    return this.has_floor ? [...this.cover_figs, this.floor] : this.cover_figs;
                },
                get has_floor() {
                    return this.floor !== null;
                },
                get cover_widest_diameter() {
                    const value = _.reduce(this.cover_figs, (res, p) => Math.max(res, p.diameter), Number.MIN_VALUE);
                    return humanize_distance(value);
                },
                get cover_area() {
                    const value = _.reduce(this.cover_figs, (res, p) => res + p.area * ZOME.num, 0);
                    return humanize_area(value);
                },
                get cover_num_figs() {
                    return ZOME.num * this.cover_figs.length;
                },
                get floor_diameter() {
                    const value = this.floor ? this.floor.diameter : 0;
                    return humanize_distance(value);
                },
                get floor_area() {
                    const value = this.floor ? this.floor.area : 0
                    return humanize_area(value);
                },
                get floor_perimeter() {
                    const value = this.floor ? this.floor.perimeter : 0
                    return humanize_distance(value);
                },
                format(key, value) {
                    return to_decimal(value, FLOAT_2_STR_PRECISION);
                },
                get_slider(key) {
                    return eval(`this.$refs.${key}_slider`);
                },
                clamp(key, value) {
                    const slider = this.get_slider(key);
                    this.params[key] = this.format(key, _.clamp(value, slider.min, slider.max));
                },
                download_tsv() {
                    this.download_csv("\t", "tsv");
                },
                download_csv(sep = ";", fmt = "csv") {
                    const hr = "# ------------------------------\n"

                    // Add comments
                    let obj = hr;
                    obj += `# ${this.i18n('zome_made_with')} Z5omes\n`;
                    obj += `# https://florianwns.github.io/z5omes/\n`;
                    obj += hr;
                    obj += `# ${this.i18n('cover_num_figures')} : ${this.cover_num_figs}\n`;
                    obj += `# ${this.i18n('cover_widest_diameter')} : ${this.cover_widest_diameter}\n`;
                    obj += `# ${this.i18n('cover_area')} : ${this.cover_area}\n`;
                    obj += `# ${this.i18n('floor_perimeter')} : ${this.floor_perimeter}\n`;
                    obj += `# ${this.i18n('floor_diameter')} : ${this.floor_diameter}\n`;
                    obj += `# ${this.i18n('floor_area')} : ${this.floor_area}\n`;
                    obj += hr;
                    obj += _.join(this.table_column_names, sep) + "\n"
                    const rows = this.table_rows;
                    _.forEach(rows, row => {
                        obj += _.join(row[1], sep) + "\n"
                    });
                    download(`zome_measurements.${fmt}`, `data:text/${fmt}; charset=utf-8,` + encodeURIComponent(obj));
                },
                get table_column_names() {
                    return [
                        this.i18n('id'),
                        this.i18n('width'),
                        this.i18n('height'),
                        this.i18n('edges'),    // CCW Edges
                        this.i18n('angles'),   // CCW Angles
                        this.i18n('slope_angle'),
                        this.i18n('area'),
                        this.i18n('diameter'),
                    ]
                },
                get table_rows() {
                    const rows = new Array(this.figs.length);
                    _.forEach(this.figs, (fig, i) => {
                        rows[i] = [fig, [
                            i + 1,
                            humanize_distance(fig.width),
                            humanize_distance(fig.height),
                            humanize_arr(unique_arr(_.map(fig.edge_distances, v => humanize_distance(v)))),
                            humanize_arr(unique_arr(_.map(fig.angles, a => humanize_angle(rad2deg(a))))),
                            humanize_angle(rad2deg(fig.slope)),
                            humanize_area(fig.area),
                            humanize_distance(fig.diameter),
                        ]];
                    });
                    return rows;
                },
                process() {
                    this.__to_real_world();
                },
                to_svg_points(piece, size) {
                    // Recompute pixel positions
                    const [xMin, xMax, yMin, yMax] = get_boundaries(piece.points);
                    const pixel_ratio = size / Math.max(piece.height, piece.width);
                    const center = size / 2;
                    return piece.points.map(p => [
                        (p[0] - xMin - piece.width / 2) * pixel_ratio + center,
                        (p[1] - yMin - piece.height / 2) * pixel_ratio + center,
                    ]);
                },
                to_real_world() {
                    // Clone structure
                    const cover_3D = ZOME.cover_3D;
                    const num_figs = cover_3D.length;

                    // Resize cover figs
                    const cover_figs = new Array(num_figs);
                    _.forEach(cover_3D, (fig, i) => {
                        // Planar fig
                        let planar_fig = fig.planar();
                        cover_figs[i] = planar_fig;
                    });

                    // Refresh proxy
                    this.floor = (ZOME.floor) ? ZOME.floor.planar() : null;
                    this.cover_figs = cover_figs;
                },
            };
        });

        Alpine.data('renderer_a4', () => {
            let svg_elements_per_page = [];
            let pages = [];
            let page_bounds = [];

            return {
                A4_sheet: null,
                num_pages: 0,
                page_index: 0,
                pages: [],
                bulleted_list_colors: [],
                zoom: 1,
                num_col: 1,
                kind_of_drawing: "mandala_figs",
                draw_color: true,
                draw_centroid: false,

                // 2D Rendering Parameters
                init() {
                    this.A4_sheet = this.$refs.A4_sheet;

                    // Add listeners
                    this.$watch("kind_of_drawing", () => {
                        this.process();
                    });

                    this.$watch("page_index", () => {
                        this.draw();
                    });

                    _.forEach(["zoom", "draw_color", "draw_centroid"], key => this.$watch(key, () => {
                            this.build_elements_per_page();
                            this.draw();
                        })
                    );

                    this.$el.addEventListener("keydown", e => this.keydown(e.key) && e.preventDefault(), false);

                    // Add swipe
                    const hammer = new Hammer(this.A4_sheet.parentNode);
                    hammer.on('swiperight', (e) => this.previous_page());
                    hammer.on('swipeleft', (e) => this.next_page());
                },
                get grid_pct() {
                    // Compute Grid size in percent for css drawing
                    return 100 / this.num_col;
                },
                to_svg_points(piece, size) {
                    // Recompute pixel positions
                    const center = size / 2;
                    const pixel_ratio = size / Math.max(piece.height, piece.width);
                    return piece.points.map(p => [p[0] * pixel_ratio + center, p[1] * pixel_ratio]);
                },
                download_pdf() {
                    // Create empty PDF document
                    const [A4_width, A4_height] = [595, 842];
                    const doc = new PDFDocument({compress: false, size: [A4_width, A4_height]});
                    const stream = doc.pipe(blobStream());

                    // Create SVG
                    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                    svg.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns', 'http://www.w3.org/2000/svg');
                    svg.setAttribute('viewBox', '0 0 210 297');

                    const size = {width: A4_width * this.num_col, height: A4_height * this.num_col};
                    const num_sheet_per_svg = this.num_col * this.num_col;

                    _.forEach(svg_elements_per_page, (elements, iP) => {
                        // Create the svg with elements
                        svg.innerHTML = '';
                        _.forEach(elements, element => svg.appendChild(element));

                        // Split the drawing into multiple A4 sheets depends on the num_col
                        for (let i = 0; i < num_sheet_per_svg; i++) {
                            for (let j = 0; j < this.num_col; j++) {
                                const x = -j * A4_width;
                                const y = -i * A4_height;
                                SVGtoPDF(doc, svg, x, y, size);

                                // Add page if it's not the last
                                if ((i + 1) * (j + 1) < num_sheet_per_svg - 1) {
                                    doc.addPage()
                                }
                            }
                        }

                        // Add page if it's not the last
                        if (iP < svg_elements_per_page.length - 1) {
                            doc.addPage()
                        }
                    });

                    // Save document
                    doc.end();

                    const filename = this.gen_filename("_planar_figs.pdf");
                    stream.on('finish', function () {
                        const url = stream.toBlobURL("application/pdf");
                        download(filename, url);
                    });

                    // Tricks because svg is empty otherwise ;)
                    this.draw();
                },
                download_svg() {
                    const svg = this.A4_sheet.outerHTML;
                    const blob = new Blob([svg.toString()]);
                    const filename = this.gen_filename("_planar_figs.svg");
                    download(filename, window.URL.createObjectURL(blob));
                },
                process() {
                    // Init variables
                    pages = [];
                    switch (this.kind_of_drawing) {
                        case 'spiral_figs':
                            this.draw_spiral_figs();
                            break;
                        case 'mandala_figs':
                            this.draw_mandala_figs();
                            break;
                    }

                    // Compute boundaries for all pages
                    page_bounds = new Array(pages.length);
                    _.forEach(pages, (page_figs, iP) => {
                        // Reset boundaries
                        let xMax = Number.MIN_VALUE, yMax = Number.MIN_VALUE,
                            xMin = Number.MAX_VALUE, yMin = Number.MAX_VALUE;

                        // Compute boundaries of all figs
                        for (const fig of page_figs) {
                            const [xPMin, xPMax, yPMin, yPMax] = get_boundaries(fig.points);

                            // Save boundaries
                            if (xPMin < xMin) xMin = xPMin;
                            if (xPMax > xMax) xMax = xPMax;
                            if (yPMin < yMin) yMin = yPMin;
                            if (yPMax > yMax) yMax = yPMax;
                        }

                        const width = Math.abs(xMax - xMin);
                        const height = Math.abs(yMax - yMin);
                        page_bounds[iP] = [xMin, yMin, width, height];
                    });

                    // Add bulleted list
                    const bulleted_list_colors = new Array(pages.length);
                    _.forEach(pages, (page_figs, iP) => {
                        // Add color of the first piece to bulleted list
                        bulleted_list_colors[iP] = page_figs[0].color.hex;
                    });

                    // Save proxies
                    this.bulleted_list_colors = bulleted_list_colors;

                    this.build_elements_per_page();
                    this.page_index = 0;
                    this.draw();
                },
                build_elements_per_page() {
                    // Compute the same pixel ratio for all pages
                    const maxWidth = _.reduce(page_bounds, (res, arr) => Math.max(res, arr[2]), Number.MIN_VALUE);
                    const maxHeight = _.reduce(page_bounds, (res, arr) => Math.max(res, arr[3]), Number.MIN_VALUE);
                    const border = 6;
                    const pixel_ratio = Math.min(
                        (210 - 2 * border) / maxWidth, (297 - 6 * border) / maxHeight
                    ) * this.zoom;
                    const center = [210 / 2, 297 / 2];

                    // Build pages figs
                    svg_elements_per_page = new Array(pages.length);
                    let iF, points;
                    _.forEach(pages, (page, iPa) => {
                        const num_elements = this.draw_centroid ? page.length * 2 + 1 : page.length + 1;
                        const svg_elements = new Array(num_elements);
                        iF = 0;
                        _.forEach(page, fig => {
                            const el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                            const [xMin, yMin, width, height] = page_bounds[iPa];
                            points = fig.points.map(p => [
                                (p[0] - xMin - width / 2) * pixel_ratio + center[0],
                                (p[1] - yMin - height / 2) * pixel_ratio + center[1],
                            ]);
                            el.setAttribute('points', `${points}`);
                            el.setAttribute('stroke', 'black');
                            el.setAttribute('stroke-width', '0.1px');
                            el.setAttribute('fill', this.draw_color ? fig.color.hex : 'transparent');
                            svg_elements[iF] = el;
                            iF++
                            if (this.draw_centroid) {
                                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                                const centroid = d3.polygonCentroid(points);
                                c.setAttribute('cx', `${centroid[0]}`);
                                c.setAttribute('cy', `${centroid[1]}`);
                                c.setAttribute('r', '1');
                                svg_elements[iF] = c;
                                iF++;
                            }
                        });

                        // Add Text
                        const el = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        el.setAttribute('text-anchor', 'end');
                        el.setAttribute('x', (210 - border).toString());
                        el.setAttribute('y', (297 - border).toString());
                        el.setAttribute('font-family', "Verdana")
                        el.setAttribute('font-size', "6px")
                        el.innerHTML = `Page ${iPa + 1}/${pages.length}`;
                        svg_elements[iF] = el;

                        // Add color of the first piece to bulleted list
                        svg_elements_per_page[iPa] = svg_elements;
                    });
                },
                draw_mandala_figs() {
                    const planar_cover_2D = ZOME.planar_cover_2D;

                    // For each color, rotate piece around the origin
                    const mandala_figs = [], O = [0, 0, 0];
                    for (let i = 0; i < ZOME.num; i++) {
                        _.forEach(planar_cover_2D, (spiral_fig, j) => {
                            const fig = _.cloneDeep(spiral_fig);
                            fig.points = fig.points.map(p => rotate_2d(p, -ZOME.rotation_angles[i], O));
                            fig.color = ZOME.rotated_colors[fig.color.hex][i];
                            mandala_figs.push(fig)
                        });
                    }

                    if (mandala_figs.length > 0) {
                        pages.push(mandala_figs);
                    }

                    // Add a last page if floor exists
                    if (ZOME.floor !== null) {
                        pages.push([ZOME.floor.planar()]);
                    }
                },
                draw_spiral_figs() {
                    const planar_cover_2D = ZOME.planar_cover_2D;

                    // For each color, Add a page with cover_3D figs
                    for (let i = 0; i < ZOME.num; i++) {
                        const colored_spiral_figs = [];
                        _.forEach(planar_cover_2D, (spiral_fig, j) => {
                            const fig = _.cloneDeep(spiral_fig);
                            fig.color = ZOME.rotated_colors[fig.color.hex][i];
                            colored_spiral_figs.push(fig)
                        });
                        pages.push(colored_spiral_figs);
                    }

                    // Add Floor at last page if floor exists
                    if (ZOME.floor !== null) {
                        pages.push([ZOME.floor.planar()]);
                    }
                },
                next_page() {
                    this.page_index = (this.page_index + 1) % svg_elements_per_page.length;
                },
                previous_page() {
                    this.page_index = (svg_elements_per_page.length + this.page_index - 1) % svg_elements_per_page.length;
                },
                keydown(key) {
                    switch (key) {
                        case "Up":
                        case "ArrowUp":
                        case "Left":
                        case "ArrowLeft":
                            this.previous_page();
                            break;
                        case "Down":
                        case "ArrowDown":
                        case "Right":
                        case "ArrowRight":
                            this.next_page();
                            break;
                        default:
                            return false;
                    }
                    return true;
                },
                draw() {
                    this.A4_sheet.innerHTML = '';
                    if (svg_elements_per_page.length <= 0) {
                        return;
                    }
                    const elements = svg_elements_per_page[this.page_index % svg_elements_per_page.length];
                    for (const el of elements) {
                        this.A4_sheet.appendChild(el);
                    }
                }
            };
        });

        Alpine.data('renderer_3D', () => {
            let scene, camera, renderer, controls, canvas;              // Three JS Parameters
            const meshes = {
                "axis": null,
                "zome_obj": null,
                "zome_edges": null,
                "zome_vertices": null,
                "vanishing_lines": null,
            }

            return {
                // 3D Rendering Parameters
                is_spinning: false,
                speed: 0.001,
                type_of_3D_objects: "skeleton_3D",

                draw_axis: true,
                draw_vanishing_lines: true,
                draw_zome_vertices: false,

                show_vanishing_lines_switch: false,
                show_vertices_switch: false,

                is_fullscreen: false,
                __auto_size: null,

                init() {
                    this.__auto_size = _.debounce(this.auto_size, 1);

                    // Add listeners
                    this.$el.addEventListener("keydown", e => this.keydown(e.key) && e.preventDefault(), false);

                    ["axis", "vanishing_lines", "zome_vertices"].forEach(
                        (key) => this.$watch(`draw_${key}`, (value) => {
                            this.set_visibility(key, value);
                        })
                    );

                    this.$watch("type_of_3D_objects", () => {
                        this.process();
                    });


                    // Screenfull lister
                    if (this.can_use_screenfull) {
                        screenfull.on('change', () => {
                            this.is_fullscreen = screenfull.isFullscreen;
                            this.__auto_size();
                        });
                    }

                    // Set Canvas Parameters
                    canvas = this.$refs.canvas_3D;
                    const [width, height] = [canvas.offsetWidth, canvas.offsetHeight]

                    // Renderer
                    renderer = new THREE.WebGLRenderer({alpha: true, antialias: true});
                    canvas.appendChild(renderer.domElement);

                    // Scene
                    scene = new THREE.Scene();

                    // Add lights
                    const ambient_light = new THREE.AmbientLight(0xffffff, 0.9);
                    scene.add(ambient_light);

                    const directional_light = new THREE.DirectionalLight(0xffffff, 0.2);
                    directional_light.position.set(0, WORLD_HEIGHT, WORLD_HEIGHT);
                    scene.add(directional_light);

                    const directional_light2 = new THREE.DirectionalLight(0xffffff, 0.2);
                    directional_light2.position.set(0, -WORLD_HEIGHT, -WORLD_HEIGHT);
                    scene.add(directional_light2);

                    // Camera ( x is red, y is green, z is blue)
                    const [field_of_view, aspect_ratio, near, far] = [75, width / height, 0.1, 10 * WORLD_HEIGHT]
                    camera = new THREE.PerspectiveCamera(field_of_view, aspect_ratio, near, far);
                    camera.position.copy(this.home);

                    // Add controls
                    controls = new THREE.OrbitControls(camera, renderer.domElement);

                    // Add (x, y, z) Axis
                    meshes.axis = new THREE.AxesHelper(WORLD_HEIGHT);
                    meshes.axis.visible = this.draw_axis;

                    scene.add(meshes.axis);

                    this.reset();
                    this.auto_size()
                    this.animate()

                    this.$dispatch('zome-renderer-is-ready');
                },
                auto_size() {
                    const [width, height] = [canvas.offsetWidth, canvas.offsetHeight]
                    if (width > 0 && height > 0) {
                        camera.aspect = width / height;
                        camera.updateProjectionMatrix();
                        renderer.setSize(width, height);
                    }
                },
                toggle_fullscreen() {
                    if (this.can_use_screenfull) {
                        screenfull.toggle(this.$refs.canvas_3D_container);
                    }
                },
                download_ply() {
                    this.export_to(THREE.PLYExporter, "ply");
                },
                download_stl() {
                    this.export_to(THREE.STLExporter, "stl");
                },
                download_obj() {
                    this.export_to(THREE.OBJExporter, "obj");
                },
                download_gltf() {
                    const exporter = new THREE.GLTFExporter();
                    exporter.parse(
                        scene,
                        (res) => {
                            const str = JSON.stringify(res, null, 2);
                            const blob = new Blob([str], {type: 'text/plain'});

                            const filename = this.gen_filename(`_${this.type_of_3D_objects}.gltf`);
                            download(filename, window.URL.createObjectURL(blob));
                        },
                        (error) => console.error(error),
                        {binary: false},
                    );
                },
                export_to(cls, ext) {
                    const exporter = new cls();
                    const str = exporter.parse(scene);
                    const blob = new Blob([str], {type: 'text/plain'});

                    const filename = this.gen_filename(`_${this.type_of_3D_objects}.${ext}`);
                    download(filename, window.URL.createObjectURL(blob));
                },
                clear() {
                    // Clean old meshes
                    if (meshes.zome_obj instanceof THREE.Group) {
                        scene.remove(meshes.zome_obj)
                    }
                    meshes.zome_obj = new THREE.Group();

                    if (meshes.zome_lines instanceof THREE.Group) {
                        scene.remove(meshes.zome_lines)
                    }
                    meshes.zome_lines = new THREE.Group();

                    if (meshes.zome_vertices instanceof THREE.Group) {
                        scene.remove(meshes.zome_vertices)
                    }
                    meshes.zome_vertices = new THREE.Group();

                    if (meshes.vanishing_lines instanceof THREE.Group) {
                        scene.remove(meshes.vanishing_lines)
                    }
                    meshes.vanishing_lines = new THREE.Group();
                },

                process() {
                    const zome_obj_rotation = (meshes.zome_obj instanceof THREE.Group)
                        ? meshes.zome_obj.rotation.y
                        : 0;

                    this.clear();

                    // Display switch buttons
                    this.show_vanishing_lines_switch = ZOME.vanishing_lines
                        && ZOME.vanishing_lines.length > 0
                        && this.type_of_3D_objects == "skeleton_3D";

                    this.show_vertices_switch = DEBUG
                        && ZOME.vertices
                        && ZOME.vertices.length > 0;

                    // Display vanishing lines
                    {
                        const material = new THREE.LineBasicMaterial({color: 0x00ffff});
                        _.forEach(ZOME.vanishing_lines, (line) => {
                            const points = [new THREE.Vector3(...line[0]), new THREE.Vector3(...line[1])];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            meshes.vanishing_lines.add(new THREE.Line(geometry, material))
                        });
                    }

                    meshes.vanishing_lines.rotation.y = zome_obj_rotation;
                    scene.add(meshes.vanishing_lines);
                    this.set_visibility("vanishing_lines", this.show_vanishing_lines_switch && this.draw_vanishing_lines);

                    // Display zome vertices
                    {
                        const geometry = new THREE.BufferGeometry();
                        geometry.setAttribute('position', new THREE.Float32BufferAttribute(_.flattenDeep(ZOME.vertices), 3));

                        const material = new THREE.PointsMaterial({color: 0x888888, size: 20});
                        meshes.zome_vertices.add(new THREE.Points(geometry, material))
                    }
                    meshes.zome_vertices.rotation.y = zome_obj_rotation;
                    scene.add(meshes.zome_vertices);
                    this.set_visibility("zome_vertices", this.show_vertices_switch && this.draw_zome_vertices);

                    // Use same material for all faces
                    const material = new THREE.MeshLambertMaterial({side: THREE.DoubleSide, vertexColors: true});
                    const edge_material = new THREE.LineBasicMaterial({color: 0x333333});

                    // Build 3D Skeleton Faces
                    const spiral = eval(`ZOME.${this.type_of_3D_objects}`);
                    if (spiral) {
                        // Pre-Compute geometry points, colors and num_faces
                        let face_points = [];
                        let edge_points = [];

                        const num_figs = spiral.length;
                        if (num_figs) {
                            const colors = new Array(num_figs);
                            const num_faces = new Array(num_figs);
                            const face_colors = new Array(num_figs);
                            _.forEach(spiral, (obj, i) => {
                                face_points.push(...obj.faces);
                                edge_points.push(...obj.edge_points);
                                num_faces[i] = obj.num_faces;
                                colors[i] = ZOME.rotated_colors[obj.color.hex];
                            });

                            // Build geometry of first cover_3D
                            const spiral_geometry = new THREE.BufferGeometry().setFromPoints(face_points)
                            spiral_geometry.computeVertexNormals()
                            const edge_geometry = new THREE.BufferGeometry().setFromPoints(edge_points)

                            // Compute All faces geometries and colors
                            for (let i = 0; i < ZOME.num; i++) {
                                const rotated_spiral_geometry = spiral_geometry.clone()
                                rotated_spiral_geometry.points
                                // Rotate the new geometry
                                const a = ZOME.rotation_angles[i];
                                rotated_spiral_geometry.rotateY(a);

                                // Get colors
                                for (let j = 0; j < num_figs; j++) {
                                    face_colors[j] = _.times(num_faces[j], _.constant(colors[j][i].rgb));
                                }

                                rotated_spiral_geometry.setAttribute('color', new THREE.Float32BufferAttribute(_.flattenDeep(face_colors), 3));
                                meshes.zome_obj.add(new THREE.Mesh(rotated_spiral_geometry, material))

                                const rotated_edge_geometry = edge_geometry.clone()
                                rotated_edge_geometry.rotateY(a);

                                const spiral_lines = new THREE.LineSegments(rotated_edge_geometry, edge_material);
                                meshes.zome_lines.add(spiral_lines);
                            }
                        }
                    }

                    // Draw Zome Floor only if draw cover
                    if (this.type_of_3D_objects == "cover_3D") {
                        // Build 3D Floor Faces
                        const floor = ZOME.floor;
                        if (floor !== null) {
                            const floor_geometry = new THREE.BufferGeometry();
                            floor_geometry.setFromPoints(floor.faces)

                            const face_colors = [];
                            _.forEach(floor.faces, () => {
                                face_colors.push(...floor.color.rgb);
                            });

                            floor_geometry.setAttribute('color', new THREE.Float32BufferAttribute(face_colors, 3));
                            floor_geometry.computeVertexNormals()

                            meshes.zome_obj.add(new THREE.Mesh(floor_geometry, material))

                            const edge_geometry = new THREE.BufferGeometry().setFromPoints(floor.edge_points)
                            const spiral_lines = new THREE.LineSegments(edge_geometry, edge_material);
                            meshes.zome_lines.add(spiral_lines);
                        }
                    }

                    // Add the final obj mesh to the scene
                    meshes.zome_obj.rotation.y = zome_obj_rotation;
                    meshes.zome_lines.rotation.y = zome_obj_rotation;
                    scene.add(meshes.zome_obj);
                    scene.add(meshes.zome_lines);
                },
                get right() {
                    return new THREE.Vector3(WORLD_HEIGHT * 1.5, WORLD_HEIGHT * 0.5, 0);
                },
                get left() {
                    return new THREE.Vector3(0, WORLD_HEIGHT * 0.5, WORLD_HEIGHT * 1.5);
                },
                get down() {
                    return new THREE.Vector3(0, -WORLD_HEIGHT * 2, 0);
                },
                get up() {
                    return new THREE.Vector3(0, WORLD_HEIGHT * 2, 0);
                },
                get home() {
                    const axis = new THREE.Vector3(0, 1, 0);
                    const angle = Math.PI / 4;
                    return this.left.applyAxisAngle(axis, angle);
                },
                set_visibility(key, value) {
                    if (meshes.hasOwnProperty(key) && meshes[key].hasOwnProperty("visible")) {
                        meshes[key].visible = value
                    }
                },
                update() {
                    if (this.is_spinning) {
                        if (meshes.zome_vertices instanceof THREE.Group) {
                            meshes.zome_vertices.rotation.y -= this.speed
                        }
                        if (meshes.zome_lines instanceof THREE.Group) {
                            meshes.zome_lines.rotation.y -= this.speed
                        }
                        if (meshes.vanishing_lines instanceof THREE.Group) {
                            meshes.vanishing_lines.rotation.y -= this.speed
                        }
                        if (meshes.zome_obj instanceof THREE.Group) {
                            meshes.zome_obj.rotation.y -= this.speed
                        }
                    }
                },
                render() {
                    renderer.render(scene, camera)
                },
                animate() {
                    this.update()
                    this.render()
                    requestAnimationFrame(this.animate.bind(this));
                },
                move(v) {
                    camera.position.copy(v);
                    controls.update();
                },
                reset() {
                    this.speed = 0.001;
                    controls.reset();
                    controls.target.set(0, WORLD_HEIGHT / 2.5, 0);
                    controls.update();
                },
                keydown(key) {
                    switch (key) {
                        case "*":
                            this.speed += 0.001;
                            break;
                        case "/":
                            this.speed -= 0.001;
                            break;
                        case " ":
                            this.is_spinning = !this.is_spinning;
                            break;
                        case "e":
                        case "E":
                            this.type_of_3D_objects = "cover_3D";
                            break;
                        case "h":
                        case "H":
                            this.reset();
                            break;
                        case "m":
                        case "M":
                            this.type_of_3D_objects = "mandala_3D";
                            break;
                        case "s":
                        case "S":
                            this.type_of_3D_objects = "skeleton_3D";
                            break;
                        case "Down":
                        case "ArrowDown":
                            this.move(this.down);
                            break;
                        case "Up":
                        case "ArrowUp":
                            this.move(this.up);
                            break;
                        case "Left":
                        case "ArrowLeft":
                            this.move(this.left);
                            break;
                        case "Right":
                        case "ArrowRight":
                            this.move(this.right);
                            break;
                        default:
                            return false;
                    }
                    return true
                },
            };
        });

        Alpine.data('settings', () => {
            return {
                // Group parameters
                params: {
                    // Language parameters
                    language: null,

                    // Shape Parameters
                    num: 10,                            // number of figs (kites or diamonds)
                    theta_deg: 52,                      // In degrees, angle of shape which allows to calculate the slope of the first rhombus.
                    angle_unit: "deg",                  // Degrees or Radians
                    height_ratio: 0.6,                  // Height ratio as proportion of pole-to-pole distance (0.5 => middle)
                    kite_ratio: 1,                      // Kite ratio, lower half to upper half (1 => is rhombus else kites)

                    // Sizing Parameters
                    measuring_unit: "cm",                               // Measuring unit by default is cm
                    zome_height_in_mm: WORLD_HEIGHT,                    // Height in mm
                    timber_width_in_mm: 60,                             // Timber width in mm
                    timber_thickness_in_mm: 40,                         // Timber thickness in mm
                    z_vanishing_point_in_mm: 0,
                    assembly_method: 0,
                    assembly_direction: 0,
                    xpansion_direction: 1,
                    strengthening_of_timbers: 0,

                    // Commons parameters
                    help_is_displayed: false,
                    paint_similar_pieces: false,
                },
                params_backup: null,

                is_computing: true,
                suggested_height_ratio: null,       // Value to magnetize the zome to the nearest cut
                colors: [],
                i18n_dictionary: {},

                // Debouncers
                __make_zome: null,

                async init() {
                    this.__make_zome = _.debounce(this.make_zome, 1);

                    // Dynamic default params
                    this.params.z_vanishing_point_in_mm = this.zome_centroid;

                    // Update translated texts
                    this.$watch(`i18n_dictionary`, (value) => {
                        // remove old tooltips
                        const old_tooltips = document.getElementsByClassName('tooltip');
                        if (old_tooltips) {
                            _.map(old_tooltips, (e) => e.remove());
                        }

                        const tooltip_trigger_elements = document.querySelectorAll('[data-bs-toggle="tooltip"]')
                        const new_tooltips = [...tooltip_trigger_elements].map((el) => {
                            return new bootstrap.Tooltip(el, {
                                placement: "bottom",
                                trigger: "hover",
                            });
                        });
                    });

                    // Change language listener
                    this.$watch(`params.language`, (value) => {
                        this.set_language(this.params.language);
                    });

                    // Init params
                    this.params = sync_params_from_url(this.params);
                    if (!this.params.language) {
                        this.params.language = I18_DEFAULT_LANGUAGE;
                    }
                    this.save_params(false);

                    // Add shape parameter listeners
                    const zome_param_keys = Object.keys(this.params).filter(el => el !== 'language');
                    _.forEach(zome_param_keys, key => {
                        this.$watch(`params.${key}`, (value) => {
                            this.clamp(key, value);
                            this.__make_zome();
                        });
                    });


                    // Refresh the height_ratio if you change the zome params.num
                    this.$watch("params.num", (value) => {
                        this.clamp("height_ratio", this.params.height_ratio);
                    });

                    // Refresh data related to the height
                    // if you change the zome height
                    this.$watch("params.zome_height_in_mm", (value) => {
                        this.clamp("z_vanishing_point_in_mm", this.z_vanishing_point_in_mm);
                    });

                    _.forEach(["height_ratio", "zome_height_in_mm"], key => {
                        this.$watch(`params.${key}`, (value) => {
                            this.clamp("z_vanishing_point_in_mm", this.zome_centroid);
                        });
                    });


                    // Use ClipboardJS to copy URL
                    const clipboard = new ClipboardJS("#copy-url-btn", {
                        text: function (trigger) {
                            return document.location.href;
                        }
                    });

                    const self = this;
                    clipboard.on('success', function (e) {
                        self.show_toast(this.i18n('toast_link_copied'), "link");
                    });
                    clipboard.on('error', function (e) {
                        self.show_error();
                    });
                },
                set_language(lng) {
                    // verify that the language exists
                    const new_lng = (I18N_LANGUAGES.hasOwnProperty(this.params.language) && I18N_LANGUAGES[this.params.language].hasOwnProperty("dictionary"))
                        ? lng
                        : I18_DEFAULT_LANGUAGE;

                    // Get dictionary to apply new language
                    this.i18n_dictionary = I18N_LANGUAGES[new_lng].dictionary;

                    // Save params to url
                    sync_url_from_params(this.params)
                },
                i18n(key, value = null) {
                    // Translation function using JSON dictionnaries

                    // Return the key if not found in language and default language dictionaries
                    let translated_txt = key;

                    if (this.i18n_dictionary.hasOwnProperty(key)) {
                        translated_txt = this.i18n_dictionary[key];
                    } else if (this.i18n_default_dictionary.hasOwnProperty(key)) {
                        translated_txt = this.i18n_default_dictionary[key];
                    } else {
                        console.warn(`Translation '${key}' not founded !`);
                    }

                    if (value) {
                        translated_txt = translated_txt.replaceAll('$1', value);
                    }

                    return translated_txt;
                },
                get i18n_default_dictionary() {
                    if (!(I18N_LANGUAGES.hasOwnProperty(I18_DEFAULT_LANGUAGE)
                        && I18N_LANGUAGES[I18_DEFAULT_LANGUAGE].hasOwnProperty("dictionary")
                    )) {
                        console.error(`This language '${I18_DEFAULT_LANGUAGE}' is not available`)
                        return;
                    }

                    return I18N_LANGUAGES[I18_DEFAULT_LANGUAGE].dictionary;
                },
                show_error(error = null) {
                    self.show_toast(this.i18n('toast_error'), "triangle-exclamation", true);
                },
                get theta() {
                    switch (this.params.angle_unit) {
                        case "rad":
                            return to_decimal(deg2rad(this.params.theta_deg));
                        case "tan":
                            return to_decimal(Math.tan(deg2rad(this.params.theta_deg)));
                        case "deg":
                        default:
                            return this.params.theta_deg;
                    }
                },
                set theta(angle) {
                    switch (this.params.angle_unit) {
                        case "rad":
                            this.params.theta_deg = rad2deg(angle)
                            break;
                        case "tan":
                            this.params.theta_deg = rad2deg(Math.atan(angle))
                            break;
                        case "deg":
                        default:
                            this.params.theta_deg = angle;
                    }
                },

                get num_rhombus() {
                    return to_decimal(this.params.num * this.params.height_ratio - 1, 0);
                },
                set num_rhombus(value) {
                    this.params.kite_ratio = 1;
                    this.params.height_ratio = to_decimal((value + 1) / this.params.num);
                },
                get is_rhombus() {
                    return this.params.kite_ratio === 1;
                },
                set is_rhombus(value) {
                    if (value === true) {
                        this.params.kite_ratio = 1
                    }
                },

                get zome_height() {
                    return from_mm(this.params.zome_height_in_mm, this.params.measuring_unit);
                },
                set zome_height(value) {
                    this.clamp("zome_height_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get timber_width() {
                    return to_decimal(from_mm(this.params.timber_width_in_mm, this.params.measuring_unit));
                },
                set timber_width(value) {
                    this.clamp("timber_width_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get max_timber_width() {
                    return to_decimal(this.first_crown_radius / 2, FLOAT_2_STR_PRECISION);
                },
                get timber_thickness() {
                    return to_decimal(from_mm(this.params.timber_thickness_in_mm, this.params.measuring_unit));
                },
                set timber_thickness(value) {
                    this.clamp("timber_thickness_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get max_timber_thickness() {
                    return to_decimal(this.first_crown_radius * Math.sin(Math.PI / (this.params.num)), FLOAT_2_STR_PRECISION);
                },
                set z_vanishing_point(value) {
                    this.clamp("z_vanishing_point_in_mm", to_mm(value, this.params.measuring_unit));
                },
                get z_vanishing_point() {
                    return to_decimal(from_mm(this.params.z_vanishing_point_in_mm, this.params.measuring_unit), FLOAT_PRECISION);
                },
                get zome_centroid() {
                    // vertical center of entire zome
                    return Math.max(0, this.params.zome_height_in_mm - this.params.zome_height_in_mm / this.params.height_ratio / 2);
                },
                get min_z_vanishing_point() {
                    return (this.params.height_ratio > 0.75) ? this.params.zome_height_in_mm * 0.25 : 0;
                },
                get max_z_vanishing_point() {
                    return this.params.zome_height_in_mm * 0.75;
                },
                get is_vanishing_centered() {
                    return to_decimal(this.params.z_vanishing_point_in_mm) === to_decimal(this.zome_centroid);
                },
                set is_vanishing_centered(value) {
                    if (value === true) {
                        this.params.z_vanishing_point_in_mm = this.zome_centroid;
                    }
                },
                get is_partial() {
                    return !(this.params.height_ratio == 1 && this.params.kite_ratio == 1);
                },
                get total_height() {
                    return this.params.zome_height_in_mm / this.params.height_ratio;
                },
                get k_sum() {
                    return this.is_rhombus ? this.params.num : (1 - Math.pow(this.params.kite_ratio, this.params.num)) / (1 - this.params.kite_ratio);
                },
                // First crown properties
                get first_edge() {
                    return this.total_height / (this.k_sum * Math.cos(deg2rad(this.params.theta_deg)));
                },
                get first_crown_radius() {
                    return this.first_edge * Math.sin(deg2rad(this.params.theta_deg));
                },
                get first_crown_height() {
                    return this.first_edge * Math.cos(deg2rad(this.params.theta_deg));
                },
                get can_use_screenfull() {
                    return screenfull && screenfull.isEnabled && !IS_MOBILE;
                },
                reset_params() {
                    this.params = _.cloneDeep(this.params_backup);
                    this.show_toast(this.i18n('toast_settings_restored'), "rotate")
                },
                save_params(toast = true) {
                    this.params_backup = _.cloneDeep(this.params);
                    if (toast) {
                        this.show_toast(this.i18n('toast_settings_save'), "floppy-disk")
                    }
                },
                show_toast(txt, icon = null, error = false) {
                    // Update toast message and display it
                    const toast_msg = document.getElementById('toast_msg')
                    const txt_class = (error) ? "text-danger" : "text-primary";
                    let msg = (icon)
                        ? '<i class="fa-solid fa-' + icon + ' ' + txt_class + ' me-2 "></i>'
                        : '<img src="img/logo_zome.svg" width="24" class="me-2" alt="Zome Logo">';
                    msg += txt;
                    toast_msg.innerHTML = msg

                    const live_toast = document.getElementById('live_toast')
                    const toast = new bootstrap.Toast(live_toast)
                    toast.show()
                },
                magnetize() {
                    if (this.suggested_height_ratio && this.suggested_height_ratio != this.params.height_ratio) {
                        this.params.height_ratio = this.suggested_height_ratio;
                    }
                },
                format(key, value) {
                    // Format Zome parameters by pair of [key, value]
                    switch (key) {
                        case 'params.num':
                            return to_decimal(value, 0);
                        default:
                            return to_decimal(value);
                    }
                },
                randomize_shape() {
                    _.forEach(["num", "theta_deg", "num_rhombus"], (key) => {
                            const slider = this.get_slider(key);
                            this.params[key] = _.random(slider.min, slider.max)
                        },
                    );
                    this.params.kite_ratio = 1;
                },
                get_slider(key) {
                    return eval(`this.$refs.${key}_slider`);
                },
                clamp(key, value) {
                    const slider = this.get_slider(key);
                    if (slider) {
                        this.params[key] = this.format(key, _.clamp(value, slider.min, slider.max));
                    }
                },
                to_suggested_height_ratio(y, WORLD_HEIGHT, polar_height) {
                    return to_decimal((WORLD_HEIGHT - y) / polar_height);
                },
                gen_filename(suffix) {
                    const date_str = new Date().toISOString()
                        .replaceAll('-', '')
                        .replaceAll('T', '_')
                        .replaceAll(':', '')
                        .slice(0, 9);
                    return `Z5omes_${date_str}N${this.params.num}${small_hash(this.params)}${suffix}`
                },
                add_vertex(vertices, p) {
                    vertices.push(p);
                    return vertices.length - 1;
                },
                make_zome() {
                    this.is_computing = true;

                    // Init arrays
                    let vertices = [];      // 3D point vector
                    let cover_3D = [];

                    // Config Parameters
                    const N = this.params.num;
                    const K = this.params.kite_ratio;
                    const IS_RHOMBUS = this.is_rhombus;
                    const ZOME_HEIGHT = this.params.zome_height_in_mm;
                    const TIMBER_WIDTH = this.params.timber_width_in_mm;
                    const TIMBER_THICKNESS = this.params.timber_thickness_in_mm;

                    // Get assembly parameters
                    const ASSEMBLY_METHOD = this.params.assembly_method;
                    const ASSEMBLY_DIRECTION = this.params.assembly_direction;
                    const XPANSION_DIRECTION = this.params.xpansion_direction;

                    // Constants
                    const M = N - 1;
                    const IS_PARTIAL = this.is_partial;
                    const TOTAL_HEIGHT = this.total_height;

                    // First Point at the top
                    this.add_vertex(vertices, [0, ZOME_HEIGHT, 0]);

                    // First crown properties
                    const first_crown_radius = this.first_crown_radius;
                    const first_crown_height = this.first_crown_height;

                    // Initialize variables
                    let fipc, ficc, k, u,
                        iB, iA, iC, iD, iE, iF,
                        A, B, C, D, E, F, G, H,
                        a, dist_to_ground, y, fig;
                    let last_is_truncated = false;
                    let closest_dist_to_ground = Number.MAX_VALUE;

                    // Compute rotation angles just once
                    // And add points on first crown every 'incr_rad' from left to right
                    const INCR_RAD = TAU / N;
                    const rotation_angles = new Array(N);
                    for (let i = 0; i < N; i++) {
                        a = i * INCR_RAD;
                        rotation_angles[i] = a;

                        B = [
                            first_crown_radius * Math.sin(a),
                            Math.max(0, ZOME_HEIGHT - first_crown_height),
                            first_crown_radius * Math.cos(a)
                        ];
                        this.add_vertex(vertices, B);
                    }

                    // Loop over crowns (M = N - 1), while zome does not hit ground
                    let hit_ground = false;
                    const triangles = [];
                    for (let iR = 0; iR < M && !hit_ground; iR++) {         // iR => Crown index
                        ficc = iR * N + 1;                      // First Index on current crown
                        fipc = ficc - N;                        // First index on previous crown

                        // On current crown, Loop over points from left to right
                        for (let i = 0; i < N; i++) {
                            k = (i + 1) % N

                            iA = (iR == 0) ? 0 : fipc + k;      // Index of A point          A
                            iB = ficc + i;                      // Index of B point        B ◇ C
                            iC = ficc + k;                      // Index of C point          D

                            A = vertices[iA];
                            B = vertices[iB];
                            C = vertices[iC];

                            // Compute the new point to close diamond/kite fig
                            D = add(A, mul(sub(midpoint(B, C), A), 1 + K));

                            // Draw the second part of shape while D is higher than the ground
                            y = to_decimal(D[1]);

                            // Add a tolerance to Y
                            if (y + 0.001 >= 0) {
                                // Add Shape to 3D
                                iD = this.add_vertex(vertices, D);

                                // Add only the first piece
                                if (i == 0) {
                                    fig = new CoplanarConvex3DPolygon([A, B, D, C]);
                                    cover_3D.push(fig);
                                }

                                // Close the zome => Deal with case where this crown is exactly on the ground
                                hit_ground = to_decimal(y, 2) == 0;
                                if (hit_ground) {
                                    triangles.push(iD, iD, iC);
                                }
                            } else {
                                // Compute the Truncated Kite
                                u = -B[1] / (D[1] - B[1]);
                                E = add(B, mul(sub(D, B), u));
                                F = add(C, mul(sub(D, C), u));

                                // Add Truncated Kite to 3D
                                iE = this.add_vertex(vertices, E);
                                iF = this.add_vertex(vertices, F);

                                // Add Truncated Kite to figs
                                if (i == 0) {
                                    fig = new CoplanarConvex3DPolygon([A, B, E, F, C])
                                    cover_3D.push(fig);
                                }

                                // Add last triangles to close it after if needed
                                triangles.push(iE, iF, iC);
                                hit_ground = true;
                                last_is_truncated = true;
                            }
                        }

                        // Compute the suggested height ratio for magnetize button
                        dist_to_ground = Math.abs(y);
                        if (dist_to_ground < closest_dist_to_ground) {
                            closest_dist_to_ground = dist_to_ground;
                            this.suggested_height_ratio = this.to_suggested_height_ratio(y, ZOME_HEIGHT, TOTAL_HEIGHT);
                        }
                    }

                    // Close The Zome
                    let floor_vertices = [];
                    const num_triangles = triangles.length;
                    if (num_triangles > 0) {
                        let iT = 0;
                        for (let iN = 0; iN < N; iN++) {
                            iT = iN * 3;

                            iA = triangles[(iT + 2) % num_triangles]
                            iB = triangles[(iT + 1) % num_triangles]
                            iC = triangles[(iT + 3) % num_triangles]

                            A = vertices[iA];
                            B = vertices[iB];
                            C = vertices[iC];

                            // Deal with case where B and C are too close, so we don't add them
                            const far_enough = to_decimal(dist(B, C), 2) !== 0;
                            if (far_enough) {
                                // Add triangle to figs
                                if (iT == 0) {
                                    fig = new CoplanarConvex3DPolygon([A, B, C]);
                                    cover_3D.push(fig);
                                }
                            }

                            // Push floor vertices only if zome is partial
                            if (IS_PARTIAL) {
                                floor_vertices.push(iB);
                                if (last_is_truncated && far_enough) {
                                    floor_vertices.push(iC);
                                }
                            }
                        }
                    }

                    // Finally add the floor piece
                    let floor = null;
                    if (floor_vertices.length >= 3) {
                        fig = new CoplanarConvex3DPolygon(floor_vertices.map(iV => vertices[iV]))

                        // Deal with case where points are too close to make a floor
                        const far_enough = to_decimal(dist(fig.points[0], fig.points[1]), 2) !== 0;
                        if (far_enough) {
                            floor = fig;
                        }
                    }


                    const skeleton_3D = [], vanishing_lines = [];

                    // Compute vanishing pt
                    const vanishing_pt = [0, this.params.z_vanishing_point_in_mm, 0];

                    // Build Timbers using the GoodKarma assembly method
                    let theta, hypotenuse, adjacent_side, pivot_pt,
                        thickness_offset_pt, width_offset_pt, vertical_proj_vec, horizontal_proj_vec;

                    // Divide cover figs into two parts
                    const framework_figs = [];
                    const divide_polygons_into_two_parts = this.params.strengthening_of_timbers >= 1;
                    const divide_horizontally = this.params.strengthening_of_timbers === 1;

                    _.forEach(cover_3D, (fig, j) => {
                        const use_same_fig = !divide_polygons_into_two_parts
                            || j == 0
                            || j == cover_3D.length - 1
                            || fig.num_points == 3;

                        if (use_same_fig) {
                            framework_figs.push(fig);
                        } else if (divide_horizontally) {
                            switch (fig.num_points) {
                                case 4:
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[0], fig.points[1], fig.points[3]]));
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[1], fig.points[2], fig.points[3]]));
                                    break;
                                case 5:
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[0], fig.points[1], fig.points[4]]));
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[1], fig.points[2], fig.points[3], fig.points[4]]));
                                    break;
                            }
                        } else {
                            switch (fig.num_points) {
                                case 4:
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[0], fig.points[1], fig.points[2]]));
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[2], fig.points[3], fig.points[0]]));
                                    break;
                                case 5:
                                    const mid_pt = midpoint(fig.points[2], fig.points[3]);
                                    framework_figs.push(new CoplanarConvex3DPolygon([fig.points[0], fig.points[1], fig.points[2], mid_pt]));
                                    framework_figs.push(new CoplanarConvex3DPolygon([mid_pt, fig.points[3], fig.points[4], fig.points[0]]));
                                    break;
                            }
                        }
                    });

                    _.forEach(framework_figs, (fig) => {
                        const num_points = fig.num_points;

                        const ccw_vecs = new Array(num_points),
                            cw_vecs = new Array(num_points),
                            mid_pts = new Array(num_points),
                            thickness_offset_pts = new Array(num_points),
                            width_offset_pts = new Array(num_points),
                            horizontal_proj_vecs = new Array(num_points),
                            wall_planes = new Array(num_points),
                            shifted_wall_planes = new Array(num_points),
                            previous_indexes = new Array(num_points),
                            next_indexes = new Array(num_points);

                        // Calculate vectors and projected points to avoid multiple calculations
                        _.forEach(fig.points, (first_pt, i) => {
                            const next_index = (i + 1) % fig.num_points;
                            const previous_index = (fig.num_points + i - 1) % fig.num_points;

                            previous_indexes[i] = previous_index;
                            next_indexes[i] = next_index;

                            const prev_pt = fig.points[previous_index];
                            const sec_pt = fig.points[next_index];

                            const first_2_sec_vec = sub(sec_pt, first_pt);
                            const first_2_prev_vec = sub(prev_pt, first_pt);

                            const mid_pt = midpoint(first_pt, sec_pt);
                            const mid_2_vanishing_vec = sub(vanishing_pt, mid_pt)

                            switch (ASSEMBLY_METHOD) {
                                case 0: // GoodKarma
                                    horizontal_proj_vec = cross_product(first_2_sec_vec, mid_2_vanishing_vec);
                                    thickness_offset_pt = point_to(mid_pt, horizontal_proj_vec, TIMBER_THICKNESS);
                                    vertical_proj_vec = cross_product(horizontal_proj_vec, first_2_sec_vec);

                                    width_offset_pt = point_to(thickness_offset_pt, vertical_proj_vec, TIMBER_WIDTH);

                                    // Multiply vertical proj by xpansion direction
                                    vertical_proj_vec = mul(vertical_proj_vec, XPANSION_DIRECTION);
                                    break;
                                case 1: // Beveled GoodKarma
                                case 2: // Outward Xpansion
                                    theta = fig.angles[i];
                                    hypotenuse = TIMBER_THICKNESS / Math.sin(theta);
                                    adjacent_side = TIMBER_THICKNESS / Math.tan(theta);
                                    pivot_pt = point_to(mid_pt, first_2_sec_vec, -adjacent_side);

                                    thickness_offset_pt = point_to(pivot_pt, first_2_prev_vec, hypotenuse);
                                    horizontal_proj_vec = sub(thickness_offset_pt, mid_pt);

                                    if (to_decimal(theta) == to_decimal(TAU_Q)) {
                                        // Add Hack to avoid issues with bad cross_products on 90° angles
                                        vertical_proj_vec = cross_product(first_2_sec_vec, first_2_prev_vec);
                                    } else if (theta > TAU_Q) {
                                        // Change direction if theta is greater than 90°,
                                        // Because pivot point is after mid_pt, so the direction is opposite
                                        vertical_proj_vec = cross_product(horizontal_proj_vec, first_2_prev_vec);
                                    } else {
                                        // The normal way if theta is smaller than 90 °
                                        vertical_proj_vec = cross_product(horizontal_proj_vec, mul(first_2_prev_vec, -1));
                                    }

                                    if (ASSEMBLY_METHOD == 1) {
                                        vertical_proj_vec = mul(vertical_proj_vec, -XPANSION_DIRECTION);

                                        wall_planes[i] = points_2_plane(first_pt, mid_pt, vanishing_pt);
                                        width_offset_pt = point_to(thickness_offset_pt, vertical_proj_vec, TIMBER_WIDTH);

                                        const opposite_mid_pt = plan_intersection(width_offset_pt, horizontal_proj_vec, wall_planes[i])
                                        const opposite_thickness = dist(opposite_mid_pt, width_offset_pt);

                                        // If opposite width is superior than TIMBER_THICKNESS
                                        if (opposite_thickness > TIMBER_THICKNESS) {
                                            // Reduce Timber thickness to have maximum of TIMBER_THICKNESS
                                            const thickness_delta = opposite_thickness - TIMBER_THICKNESS;
                                            thickness_offset_pt = point_to(mid_pt, horizontal_proj_vec, TIMBER_THICKNESS - thickness_delta)
                                        }
                                    }
                            }

                            width_offset_pt = point_to(thickness_offset_pt, vertical_proj_vec, TIMBER_WIDTH);

                            // Push vectors
                            ccw_vecs[i] = first_2_sec_vec;
                            cw_vecs[i] = first_2_prev_vec;
                            horizontal_proj_vecs[i] = horizontal_proj_vec;

                            // Push points
                            mid_pts[i] = mid_pt;
                            thickness_offset_pts[i] = thickness_offset_pt;
                            width_offset_pts[i] = width_offset_pt;

                            //Push Planes
                            switch (ASSEMBLY_METHOD) {
                                case 0: // GoodKarma
                                case 1: // Beveled GoodKarma
                                    // Use vanishing pt for wall
                                    wall_planes[i] = points_2_plane(first_pt, mid_pt, vanishing_pt);
                                    break;
                                case 2: // Outward Xpansion
                                    // Use vertical proj rather vanishing pt
                                    wall_planes[i] = points_2_plane(
                                        first_pt,
                                        mid_pt,
                                        point_to(mid_pt, vertical_proj_vec, 100)
                                    );
                                    break;
                            }

                            // Same floor for shifted wall
                            shifted_wall_planes[i] = points_2_plane(
                                point_to(thickness_offset_pt, first_2_sec_vec, 100),
                                thickness_offset_pt,
                                width_offset_pt,
                            );

                        });

                        // Build the prism
                        _.forEach(fig.points, (first_pt, i) => {
                            const prev_index = previous_indexes[i];    // previous index
                            const next_index = next_indexes[i];        // next index

                            // Get polygon points, first is the current point and last is n-1 point
                            thickness_offset_pt = thickness_offset_pts[i];
                            width_offset_pt = width_offset_pts[i];

                            // Get vectors
                            const mid_pt = mid_pts[i];
                            const first_2_sec_vec = ccw_vecs[i];
                            const sec_2_first_vec = cw_vecs[next_index];

                            // Compute Planes to make point intersections
                            let planes = new Array(4);
                            switch (ASSEMBLY_DIRECTION) {
                                // Clockwise Rotation
                                case 0:
                                    planes[0] = planes[1] = shifted_wall_planes[prev_index];
                                    planes[2] = planes[3] = wall_planes[next_index];
                                    break;
                                // Counterclockwise Rotation
                                case 1:
                                    planes[0] = planes[1] = wall_planes[prev_index];
                                    planes[2] = planes[3] = shifted_wall_planes[next_index];
                                    break;
                                // Symmetry Axis
                                case 2:
                                    planes[0] = wall_planes[prev_index];
                                    planes[1] = shifted_wall_planes[prev_index];
                                    planes[2] = wall_planes[next_index];
                                    planes[3] = shifted_wall_planes[next_index];
                                    break;
                            }

                            // Compute planes to find intersection points
                            horizontal_proj_vec = horizontal_proj_vecs[i];
                            const along_plane = wall_planes[i]
                            const mid_pt_with_vertical_proj = plan_intersection(
                                width_offset_pt, horizontal_proj_vec, along_plane
                            )

                            // A, B, C, D is the top part (trapezoid) of the timber
                            A = plan_intersection(mid_pt, sec_2_first_vec, planes[0]);
                            B = plan_intersection(thickness_offset_pt, sec_2_first_vec, planes[1]);
                            C = plan_intersection(mid_pt, first_2_sec_vec, planes[2])
                            D = plan_intersection(thickness_offset_pt, first_2_sec_vec, planes[3])

                            // E, F, G, H is the bottom part (trapezoid) of the timber
                            E = plan_intersection(mid_pt_with_vertical_proj, sec_2_first_vec, planes[0]);
                            F = plan_intersection(width_offset_pt, sec_2_first_vec, planes[1]);
                            G = plan_intersection(mid_pt_with_vertical_proj, first_2_sec_vec, planes[2]);
                            H = plan_intersection(width_offset_pt, first_2_sec_vec, planes[3]);

                            // Build a TrapezoidalPrism
                            const timber_prism = new TrapezoidalPrism([A, B, C, D, E, F, G, H], fig.color);
                            skeleton_3D.push(timber_prism);

                            // Add vanishing line
                            vanishing_lines.push([vanishing_pt, first_pt]);
                        });
                    });

                    // 🎨 Build rotated colors
                    let rotated_colors = {};
                    const PAINT_SIMILAR_PIECES = this.params.paint_similar_pieces;
                    const grouped_skeleton_prisms = _.groupBy(skeleton_3D, (fig) => fig.hash);
                    const grouped_cover_polygons = _.groupBy(cover_3D, (fig) => fig.hash);

                    if (PAINT_SIMILAR_PIECES) {
                        // Compute colors by hash
                        const color_by_hash = {};

                        const grouped_figures = _.merge(grouped_skeleton_prisms, grouped_cover_polygons);
                        const num_groups = Object.keys(grouped_figures).length;
                        let group_index = 0;
                        _.forIn(grouped_figures, (group, key) => {
                            const color = Color.from_index(group_index, num_groups);
                            color_by_hash[key] = color;
                            rotated_colors[color.hex] = _.times(rotation_angles.length, _.constant(color));
                            group_index++;
                        });

                        _.forEach(cover_3D, (fig) => {
                            fig.color = color_by_hash[fig.hash]
                        });

                        _.forEach(skeleton_3D, (fig) => {
                            fig.color = color_by_hash[fig.hash]
                        });
                    } else {
                        // Paint colored spirals
                        _.forEach(cover_3D, (fig) => {
                            fig.color = Color.from_angles(a, fig.slope)
                            rotated_colors[fig.color.hex] = _.map(rotation_angles, (a) => Color.from_angles(a, fig.slope));
                        });

                        _.forEach(skeleton_3D, (fig) => {
                            fig.color = Color.from_angles(a, fig.slope)
                            rotated_colors[fig.color.hex] = _.map(rotation_angles, (a) => Color.from_angles(a, fig.slope));
                        });
                    }

                    // Build planar_cover_2D and mandala_3D
                    const mandala_3D = new Array(cover_3D.length);
                    const planar_cover_2D = new Array(cover_3D.length);

                    // Compute cover planar figs
                    let O = [0, 0, 0], planar_points = [];
                    let rotated_A;
                    _.forEach(cover_3D, (fig, i) => {
                        let planar_fig = fig.planar();

                        // Move to Origin and rotate to match with previous piece
                        planar_points = planar_fig.points.map(p => add(p, O));
                        if (i > 0) {
                            a = angle(A, O, planar_points[1]);
                            rotated_A = rotate_2d(planar_points[1], a, O);

                            // Rotate the other way if rotatedA is not too close to A
                            if (to_decimal(dist(rotated_A, A)) != 0) {
                                a = -a;
                            }
                            planar_points = planar_points.map(p => rotate_2d(p, a, O));
                        }
                        O = planar_points[planar_points.length - 1];
                        A = planar_points[planar_points.length - 2];

                        // Save planar figs
                        planar_fig.points = planar_points;
                        planar_cover_2D[i] = planar_fig;

                        // Adapt points for 3D view
                        mandala_3D[i] = new CoplanarConvex3DPolygon(
                            planar_points.map(p => [p[0], p[2], p[1]]),
                            planar_fig.color,
                        );
                    });

                    // Save Zome and dispatch it
                    ZOME = new Zome({
                        num: N,
                        rotation_angles: rotation_angles,
                        rotated_colors: rotated_colors,
                        vertices: vertices,
                        cover_3D: cover_3D,
                        skeleton_3D: skeleton_3D,
                        mandala_3D: mandala_3D,
                        planar_cover_2D: planar_cover_2D,
                        floor: floor,
                        vanishing_lines: vanishing_lines,
                    });

                    // Dispatch zome
                    this.$dispatch('zome-is-made');

                    sync_url_from_params(this.params);

                    this.is_computing = false;
                },
            };
        });
    });
</script>
</body>
</html>
